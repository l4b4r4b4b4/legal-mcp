# CD Pipeline for Legal-MCP
#
# Deploys legal-mcp to Azure Kubernetes Service (AKS) using Helm.
#
# This workflow:
# - Triggers after Release workflow completes (images are built)
# - Supports manual deployments to different environments
# - Uses Helm chart from .devops/helm/legal-mcp/
# - Per-environment values from .devops/helm/values/
#
# Required Secrets:
# =================
# - AZURE_CREDENTIALS: Azure service principal JSON for AKS access
#     { "clientId": "...", "clientSecret": "...", "subscriptionId": "...", "tenantId": "..." }
# - AKS_RESOURCE_GROUP: Azure resource group containing the AKS cluster
# - AKS_CLUSTER_NAME: Name of the AKS cluster
#
# Required Variables:
# ===================
# - RUNNER_LABEL (optional): Self-hosted runner label (default: ubuntu-latest)
#
# Runner Configuration:
# =====================
# This workflow supports both GitHub-hosted and self-hosted runners.
#
# To use self-hosted runners:
# 1. Set repository variable RUNNER_LABEL to match your runner labels
#    Example: "self-hosted" or "threadripper" or "nixos"
#
# 2. Register a runner for this repo/org. Example NixOS config:
#    ```nix
#    services.github-runners."my-runner" = {
#      enable = true;
#      url = "https://github.com/OWNER/REPO";  # or org URL
#      tokenFile = "/run/secrets/github_token";
#      extraLabels = ["self-hosted" "nixos" "your-label"];
#      extraPackages = with pkgs; [docker kubectl kubernetes-helm azure-cli];
#    };
#    ```
#
# 3. Ensure runner has network access to AKS cluster API server.

name: CD - Deploy

on:
  # Auto-deploy to staging after successful release
  workflow_run:
    workflows: ["Release"]
    types: [completed]
    branches: [main]

  # Manual deployment trigger
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment"
        required: true
        type: choice
        options:
          - staging
          - production
      image_tag:
        description: "Image tag to deploy (default: latest)"
        required: false
        default: "latest"

# Only one deployment at a time per environment
concurrency:
  group: deploy-${{ github.event.inputs.environment || 'staging' }}
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: l4b4r4b4b4/legal-mcp
  HELM_CHART_PATH: .devops/helm/legal-mcp
  HELM_RELEASE_NAME: legal-mcp
  NAMESPACE: legal-mcp

jobs:
  # Gate: Only proceed if Release workflow passed
  check-release:
    name: Verify Release
    runs-on: ${{ vars.RUNNER_LABEL || 'ubuntu-latest' }}
    if: >
      github.event_name == 'workflow_dispatch' ||
      github.event.workflow_run.conclusion == 'success'
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      image_tag: ${{ steps.check.outputs.image_tag }}
      environment: ${{ steps.check.outputs.environment }}
      values_file: ${{ steps.check.outputs.values_file }}

    steps:
      - name: Check release status
        id: check
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            IMAGE_TAG="${{ github.event.inputs.image_tag }}"
            echo "Manual trigger - env: $ENVIRONMENT, tag: $IMAGE_TAG"
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event.workflow_run.conclusion }}" == "success" ]]; then
            ENVIRONMENT="staging"
            IMAGE_TAG="latest"
            echo "Release passed - deploying latest to staging"
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          else
            echo "Release did not pass - skipping deployment"
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            ENVIRONMENT="staging"
          fi

          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT

          # Map environment to values file
          case "$ENVIRONMENT" in
            staging)
              echo "values_file=.devops/helm/values/aks-testing.yaml" >> $GITHUB_OUTPUT
              ;;
            production)
              # TODO: Create production values file when ready
              echo "values_file=.devops/helm/values/aks-testing.yaml" >> $GITHUB_OUTPUT
              ;;
          esac

  # Lint Helm chart before deploying
  helm-lint:
    name: Lint Helm Chart
    runs-on: ${{ vars.RUNNER_LABEL || 'ubuntu-latest' }}
    needs: check-release
    if: needs.check-release.outputs.should_deploy == 'true'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: "v3.17.3"

      - name: Lint chart with target values
        run: |
          helm lint ${{ env.HELM_CHART_PATH }} \
            -f ${{ needs.check-release.outputs.values_file }}

      - name: Template chart (dry-run validation)
        run: |
          helm template ${{ env.HELM_RELEASE_NAME }} ${{ env.HELM_CHART_PATH }} \
            -f ${{ needs.check-release.outputs.values_file }} \
            --set image.tag=${{ needs.check-release.outputs.image_tag }} \
            --namespace ${{ env.NAMESPACE }} \
            > /dev/null
          echo "Template rendering successful"

  # ==========================================================================
  # DEPLOYMENT: Helm to AKS
  # ==========================================================================
  deploy:
    name: Deploy to AKS (${{ needs.check-release.outputs.environment }})
    runs-on: ${{ vars.RUNNER_LABEL || 'ubuntu-latest' }}
    needs: [check-release, helm-lint]
    if: needs.check-release.outputs.should_deploy == 'true'
    timeout-minutes: 15
    environment:
      name: ${{ needs.check-release.outputs.environment }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: "v3.17.3"

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ secrets.AKS_RESOURCE_GROUP }} \
            --name ${{ secrets.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: Create namespace (if needed)
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml \
            | kubectl apply -f -

      - name: Deploy with Helm
        run: |
          helm upgrade --install ${{ env.HELM_RELEASE_NAME }} ${{ env.HELM_CHART_PATH }} \
            -f ${{ needs.check-release.outputs.values_file }} \
            --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
            --set image.tag=${{ needs.check-release.outputs.image_tag }} \
            --namespace ${{ env.NAMESPACE }} \
            --wait \
            --timeout 5m \
            --atomic

      - name: Verify deployment
        run: |
          echo "## Checking rollout status..."
          kubectl rollout status deployment/${{ env.HELM_RELEASE_NAME }} \
            --namespace ${{ env.NAMESPACE }} \
            --timeout=120s

          echo ""
          echo "## Pod status:"
          kubectl get pods \
            --namespace ${{ env.NAMESPACE }} \
            -l app.kubernetes.io/name=legal-mcp \
            -o wide

      - name: Deployment summary
        if: always()
        run: |
          echo "## Deployment Summary :rocket:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Parameter | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | \`${{ needs.check-release.outputs.environment }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Image | \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.check-release.outputs.image_tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Namespace | \`${{ env.NAMESPACE }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Helm Release | \`${{ env.HELM_RELEASE_NAME }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Chart | \`${{ env.HELM_CHART_PATH }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Values | \`${{ needs.check-release.outputs.values_file }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Runner | \`${{ runner.name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show Helm release info
          echo "### Helm Release Info" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          helm list --namespace ${{ env.NAMESPACE }} 2>/dev/null >> $GITHUB_STEP_SUMMARY || echo "Could not fetch release info" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

  # ==========================================================================
  # ALTERNATIVE DEPLOYMENT OPTIONS (commented out)
  # ==========================================================================
  #
  # Option A: Docker Compose on remote host
  # ----------------------------------------
  # deploy:
  #   name: Deploy via Docker Compose
  #   runs-on: ${{ vars.RUNNER_LABEL || 'ubuntu-latest' }}
  #   needs: check-release
  #   if: needs.check-release.outputs.should_deploy == 'true'
  #   environment:
  #     name: ${{ needs.check-release.outputs.environment }}
  #
  #   steps:
  #     - name: Deploy to remote host
  #       uses: appleboy/ssh-action@v1.0.0
  #       with:
  #         host: ${{ secrets.DEPLOY_HOST }}
  #         username: ${{ secrets.DEPLOY_USER }}
  #         key: ${{ secrets.DEPLOY_SSH_KEY }}
  #         script: |
  #           cd /opt/legal-mcp
  #           docker compose pull
  #           docker compose up -d
  #
  # Option B: Fly.io
  # -----------------
  # deploy:
  #   name: Deploy to Fly.io
  #   runs-on: ${{ vars.RUNNER_LABEL || 'ubuntu-latest' }}
  #   needs: check-release
  #   if: needs.check-release.outputs.should_deploy == 'true'
  #
  #   steps:
  #     - uses: actions/checkout@v4
  #     - uses: superfly/flyctl-actions/setup-flyctl@master
  #     - run: flyctl deploy --image ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.check-release.outputs.image_tag }}
  #       env:
  #         FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
